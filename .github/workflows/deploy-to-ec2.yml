name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggers

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  deploy:
    name: ${{ github.event_name == 'pull_request' && 'Build & Validate' || 'Build & Deploy to EC2' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Build Qdrant image
        working-directory: ./dpi-assistant/backend
        run: |
          docker build --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -f Dockerfile.qdrant \
            -t dpi-assistant-qdrant .

      - name: Build Backend image
        working-directory: ./dpi-assistant/backend
        run: |
          docker build --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -t dpi-assistant-backend .

      - name: Build Frontend image
        working-directory: ./dpi-assistant
        run: |
          docker build --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -t dpi-assistant-frontend .

      - name: Build validation complete
        if: github.event_name == 'pull_request'
        run: |
          echo "‚úÖ Docker images built successfully!"
          echo "All builds passed validation. Safe to merge."

      - name: Save Docker images
        if: github.event_name == 'push'
        run: |
          docker save dpi-assistant-qdrant | gzip > dpi-assistant-qdrant.tar.gz
          docker save dpi-assistant-backend | gzip > dpi-assistant-backend.tar.gz
          docker save dpi-assistant-frontend | gzip > dpi-assistant-frontend.tar.gz

      - name: Setup SSH
        if: github.event_name == 'push'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_IP }} >> ~/.ssh/known_hosts

      - name: Create .env file for deployment
        if: github.event_name == 'push'
        run: |
          cat > .env.prod << EOF
          GOOGLE_AI_API_KEY=${{ secrets.GOOGLE_AI_API_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_KNOWLEDGE_BASE_BUCKET=${{ secrets.S3_KNOWLEDGE_BASE_BUCKET }}
          SLACK_BOT_TOKEN=${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_SIGNING_SECRET=${{ secrets.SLACK_SIGNING_SECRET }}
          SLACK_KNOWLEDGE_BASE_CHANNEL=${{ secrets.SLACK_KNOWLEDGE_BASE_CHANNEL }}
          NODE_ENV=production
          PORT=8080
          EOF

      - name: Upload images to EC2
        if: github.event_name == 'push'
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            dpi-assistant-qdrant.tar.gz \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            dpi-assistant-backend.tar.gz \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            dpi-assistant-frontend.tar.gz \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            .env.prod \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            dpi-assistant/docker-compose.prod.yml \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            dpi-assistant/nginx.conf \
            ubuntu@${{ secrets.EC2_IP }}:/home/ubuntu/

      - name: Deploy on EC2
        if: github.event_name == 'push'
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_IP }} << 'ENDSSH'
            set -e

            echo "üîß Deploying DPI Assistant..."

            # Create app directory if it doesn't exist
            sudo mkdir -p /home/ubuntu/dpi-assistant
            sudo chown -R ubuntu:ubuntu /home/ubuntu/dpi-assistant

            # Move files to app directory
            mv /home/ubuntu/dpi-assistant-*.tar.gz /home/ubuntu/dpi-assistant/ 2>/dev/null || true
            mv /home/ubuntu/docker-compose.prod.yml /home/ubuntu/dpi-assistant/ 2>/dev/null || true
            mv /home/ubuntu/.env.prod /home/ubuntu/dpi-assistant/.env 2>/dev/null || true
            mv /home/ubuntu/nginx.conf /home/ubuntu/dpi-assistant/ 2>/dev/null || true

            cd /home/ubuntu/dpi-assistant

            # Load Docker images
            echo "üì¶ Loading Docker images..."
            docker load < dpi-assistant-qdrant.tar.gz
            docker load < dpi-assistant-backend.tar.gz
            docker load < dpi-assistant-frontend.tar.gz

            # Stop and remove old containers
            echo "üîÑ Updating containers..."
            docker-compose -f docker-compose.prod.yml down || true

            # Start new containers
            echo "üöÄ Starting services..."
            docker-compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be ready..."
            sleep 30

            # Check if this is first deployment (no vectors populated)
            if docker-compose -f docker-compose.prod.yml exec -T backend sh -c "test ! -f /app/.vectors_populated" 2>/dev/null; then
              echo "üìä Populating vector database (first deployment)..."
              docker-compose -f docker-compose.prod.yml exec -T backend sh -c "cd /app && npm run populate-vectors && touch /app/.vectors_populated" || echo "‚ö†Ô∏è Vector population will be attempted on next startup"
            fi

            # Cleanup
            rm -f dpi-assistant-*.tar.gz

            echo "‚úÖ Deployment completed successfully!"
            echo "üìä Container status:"
            docker-compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Wait for services to stabilize
        if: github.event_name == 'push'
        run: |
          echo "‚è≥ Waiting for services to fully stabilize..."
          sleep 20

      - name: Verify deployment - Basic health check
        if: github.event_name == 'push'
        run: |
          echo "üîç Running basic health check..."
          HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" http://${{ secrets.EC2_IP }}/health)
          HTTP_CODE=$(echo "$HEALTH_RESPONSE" | tail -n1)
          HEALTH_BODY=$(echo "$HEALTH_RESPONSE" | sed '$d')

          echo "Health check response:"
          echo "$HEALTH_BODY" | jq '.' || echo "$HEALTH_BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Basic health check failed with HTTP $HTTP_CODE"
            exit 1
          fi

          echo "‚úÖ Basic health check passed"

      - name: Verify deployment - Full health check with chat test
        if: github.event_name == 'push'
        run: |
          echo "üîç Running comprehensive health check with chat functionality test..."
          FULL_HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" http://${{ secrets.EC2_IP }}/health/full)
          HTTP_CODE=$(echo "$FULL_HEALTH_RESPONSE" | tail -n1)
          HEALTH_BODY=$(echo "$FULL_HEALTH_RESPONSE" | sed '$d')

          echo "Full health check response:"
          echo "$HEALTH_BODY" | jq '.' || echo "$HEALTH_BODY"

          # Check if the response is valid JSON
          if ! echo "$HEALTH_BODY" | jq empty 2>/dev/null; then
            echo "‚ùå Invalid JSON response from health check"
            exit 1
          fi

          # Extract status
          STATUS=$(echo "$HEALTH_BODY" | jq -r '.status')
          CHAT_STATUS=$(echo "$HEALTH_BODY" | jq -r '.checks.chat.status')
          CHAT_MESSAGE=$(echo "$HEALTH_BODY" | jq -r '.checks.chat.message')

          echo ""
          echo "üìä Health Check Results:"
          echo "  Overall Status: $STATUS"
          echo "  Chat Status: $CHAT_STATUS"
          echo "  Chat Message: $CHAT_MESSAGE"

          # Fail if status is unhealthy
          if [ "$STATUS" = "unhealthy" ]; then
            echo "‚ùå Deployment health check failed: System is unhealthy"
            exit 1
          fi

          # Fail if chat functionality is not working
          if [ "$CHAT_STATUS" = "error" ]; then
            echo "‚ùå Chat functionality test failed: $CHAT_MESSAGE"
            exit 1
          fi

          if [ "$CHAT_STATUS" != "ok" ]; then
            echo "‚ö†Ô∏è  Warning: Chat status is '$CHAT_STATUS' - $CHAT_MESSAGE"
            if [ "$STATUS" = "healthy" ]; then
              echo "‚ö†Ô∏è  Overall status is healthy but chat is not fully operational"
            fi
          else
            echo "‚úÖ Chat functionality verified successfully"
          fi

          # Accept healthy or degraded status (degraded may mean vector store is initializing)
          if [ "$STATUS" = "healthy" ] || [ "$STATUS" = "degraded" ]; then
            echo "‚úÖ Full health check passed with status: $STATUS"
          else
            echo "‚ùå Unexpected health status: $STATUS"
            exit 1
          fi

      - name: Verify deployment - Summary
        if: github.event_name == 'push'
        run: |
          echo ""
          echo "üéâ Deployment completed and verified successfully!"
          echo ""
          echo "üìã Deployment Summary:"
          echo "  Application URL: http://${{ secrets.EC2_IP }}"
          echo "  API URL: http://${{ secrets.EC2_IP }}/api"
          echo "  Health Check: http://${{ secrets.EC2_IP }}/health"
          echo "  Full Health Check: http://${{ secrets.EC2_IP }}/health/full"
          echo ""
          echo "‚úÖ All runtime checks passed"
          echo "‚úÖ Chat functionality verified"

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f .env.prod
          rm -f dpi-assistant-*.tar.gz
